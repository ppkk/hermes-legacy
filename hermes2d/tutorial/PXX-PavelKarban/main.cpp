#define HERMES_REPORT_ALL
#include "hermes2d.h"

// This example shows how to solve a simple PDE that describes stationary 
// heat transfer in an object consisting of two materials (aluminum and 
// copper). The object is heated by constant volumetric heat sources
// generated by a DC electric current. The temperature on the boundary 
// is fixed. We will learn how to:
//
//   - load the mesh,
//   - perform initial refinements,
//   - create a H1 space over the mesh,
//   - define weak formulation,
//   - initialize matrix solver,
//   - assemble and solve the matrix system,
//   - output the solution and element orders in VTK format 
//     (to be visualized, e.g., using Paraview),
//   - visualize the solution using Hermes' native OpenGL-based functionality.
//
// PDE: Poisson equation -div(LAMBDA grad u) - VOLUME_HEAT_SRC = 0.
//
// Boundary conditions: Dirichlet u(x, y) = FIXED_BDY_TEMP on the boundary.
//
// The following parameters can be changed:

const bool HERMES_VISUALIZATION = true;           // Set to "false" to suppress Hermes OpenGL visualization. 
const bool VTK_VISUALIZATION = true;              // Set to "true" to enable VTK output.
const int P_MAG_INIT = 5;                             // Uniform polynomial degree of mesh elements.
const int INIT_REF_NUM = 0;                       // Number of initial uniform mesh refinements.
MatrixSolverType matrix_solver = SOLVER_UMFPACK;  // Possibilities: SOLVER_AMESOS, SOLVER_AZTECOO, SOLVER_MUMPS,
// SOLVER_PETSC, SOLVER_SUPERLU, SOLVER_UMFPACK.

// Problem parameters.
const double A_INIT = 0.0;
const double T_INIT = 20.0;
const double DK_INIT = 0.0;

// Weak forms.
#include "definitions.cpp"

int main(int argc, char* argv[])
{
    // Instantiate a class with global functions.
    Hermes2D hermes2d;

    // Load the mesh.
    Mesh mesh_mag;
    H2DReader mloader;
    mloader.load("mesh_mag.mesh", &mesh_mag);

    // Perform initial mesh refinements (optional).
    // for (int i=0; i < INIT_REF_NUM; i++) mesh_mag.refine_all_elements();

    // Initialize the weak formulation.
    WeakFormMagnetic wf(2);
    wf.registerForms();

    // Initialize boundary conditions.
    DefaultEssentialBCConst bc_essential(Hermes::vector<std::string>("16", "17", "18", "39", "40", "41"), 0.0);
    EssentialBCs bcs(&bc_essential);

    // Create an H1 space with default shapeset.
    H1Space space_mag_real(&mesh_mag, &bcs, P_MAG_INIT);
    H1Space space_mag_imag(&mesh_mag, &bcs, P_MAG_INIT);
    // ndof
    int ndof = Space::get_num_dofs(Hermes::vector<Space *>(&space_mag_real, &space_mag_imag));
    std::cout << "ndof: " << ndof << std::endl;

    Solution *sln_mag_real = new Solution();
    sln_mag_real->set_const(&mesh_mag, A_INIT);
    Solution *sln_mag_imag = new Solution();
    sln_mag_imag->set_const(&mesh_mag, A_INIT);

    // Set up the solver, matrix, and rhs according to the solver selection.
    SparseMatrix* matrix = create_matrix(matrix_solver);
    Vector* rhs = create_vector(matrix_solver);
    Solver* solver = create_linear_solver(matrix_solver, matrix, rhs);

    // Initialize the FE problem.
    DiscreteProblem dp(&wf, Hermes::vector<Space *>(&space_mag_real, &space_mag_imag));
    dp.assemble(matrix, rhs);

    if (solver->solve())
        Solution::vector_to_solutions(solver->get_solution(),
                                      Hermes::vector<Space *>(&space_mag_real, &space_mag_imag),
                                      Hermes::vector<Solution *>(sln_mag_real, sln_mag_imag));
    else
        error ("Matrix solver failed.\n");

    // WjFilter wjfilter(sln_mag_real, sln_mag_imag);
    MagneticVectorPotentialFilter afilter(sln_mag_real);

    // Visualize the solution.
    ScalarView view("Solution", new WinGeom(0, 0, 440, 350));
    view.show(&afilter, HERMES_EPS_NORMAL);
    View::wait();

    // Clean up.
    delete solver;
    delete matrix;
    delete rhs;

    return 0;
}
